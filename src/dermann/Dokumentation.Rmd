---
title: How to write a function that visualizes a spatial point vector attribute over a contrast stretched raster image
author: "Diana Dermann und Daniela Krampe"
date: "Wednesday, February 04, 2015"
output: html_document
---
This How-To will explain how to write a function that visualizes a spatial point vector attribute over a contrast stretched raster image. 

As always the first steps are to set the working directory and load the required packages.

```{r, warning=FALSE}

if (!require(sp)){install.packages('sp')}
if (!require(RColorBrewer)){install.packages('RColorBrewer')}
if (!require(raster)){install.packages('raster')}
if (!require(rgdal)){install.packages('rgdal')}
if (!require(latticeExtra)){install.packages('latticeExtra')}

library(sp)
library(raster)
library(rgdal)
library(RColorBrewer)
library(latticeExtra)
```

Note that the code for the installation of the packages is conditional. "Require" works just the same as "library", but instead of giving an error if the package is not installed yet, it will return "FALSE". Therefore the first block will only install the packages if they are not downloaded yet. Library loads the packages.

In the next step we'll write the function. First you will see the entire function and then the parts it contains will be discussed separately. You will have to know your dataset before you write the function. So it's a good idea to check the parameters before you start writing the function.

```{r,warning=FALSE}
visualizer <- function (raster, vector, palname="Reds",lines){
  vector_classes <- cut(vector@data$NAT, c(0, 2, 4, 6, 8, 10))
  vector_colors <- colorRampPalette(brewer.pal(5,palname))(5)
  min <- max(mean(getValues(raster)) - sd(getValues(raster)), 0)
  max <- mean(getValues(raster)) + sd(getValues(raster))
  
  breaks <- seq(min, max, length.out = 256)
  yat = seq(extent(raster)@ymin, 
            extent(raster)@ymax, length.out = lines)
  xat = seq(extent(raster)@xmin, 
            extent(raster)@xmax, length.out = lines)
  
  
  
  abb <- spplot(raster, col.regions = gray.colors(256), at = breaks,
                key = list(space = 'left', text = list(levels(vector_classes)), 
                           points = list(pch = 21, cex = 2, fill = vector_colors)),
                colorkey=list(space="right"),
                panel = function(...){
                  panel.levelplot(...)
                  panel.abline(h = yat, v = xat, col = "grey0", lwd = 0.8, lty = 3)
                  }
  )
  Farben <- spplot(vector, zcol = "NAT", col.regions = vector_colors, cuts = c(0, 2, 4, 6, 8, 10))
  
  abb + as.layer(Farben)
}
```

To create a function define the name of the function and what parameters are required to be put in by the user. In our case the user has to tell the function which raster and which vector are to be used. For the color palette the default value "Reds" is set and if you write a help page for the function it would be important to mention the "" are obligatory and only palettes from brewer.pal can be used. lines will determine the amount of coordinate grid lines on the map. Now we'll define more necessary parameters for the plot. 


    vector_classes <- cut(vector@data$NAT, c(0, 2, 4, 6, 8, 10))
    vector_colors <- colorRampPalette(brewer.pal(5,palname))(5)


The classes for the visualization of the vector have to be chosen now. In this case we are using the number of natural species, saved under NAT. As the values range between 0 and 9 the classes range from 0 to 10.
The same is done for the raster image in the following code: 


    min <- max(mean(getValues(raster)) - sd(getValues(raster)), 0)
    max <- mean(getValues(raster)) + sd(getValues(raster))

    breaks <- seq(min, max, length.out = 256)
    yat = seq(extent(raster)@ymin, 
                extent(raster)@ymax, length.out = lines)
    xat = seq(extent(raster)@xmin, 
                extent(raster)@xmax, length.out = lines)


We only want to display the values within the standard deviation to stretch the color range and ignore extreme values. For this we define the minimum and the maximum values and create a sequence of 256 values between the maximum and minimum. yat and xat create a coordinate system on top of the image. For this we use the extent of the raster image, which is saved under (raster)@ymin, (raster)@ymax, (raster)@xmin, (raster)@xmax. By creating a sequence of 5 the image is going to be divided by 4 lines. To understand this keep in mind that the limits are also counted as lines. At this point we're just creating the variable to be used in the plot funtion below.

    abb <- spplot(raster, col.regions = gray.colors(256), at = breaks,
                
                key = list(space = 'left', text = list(levels(vector_classes)),
                           points = list(pch = 21, cex = 2, fill = vector_colors)),
                           
                colorkey=list(space="right"),
                
                panel = function(...){
                panel.levelplot(...)
                panel.abline(h = yat, v = xat, col = "grey0", lwd = 0.8, lty = 3)
                  

Now we create the basis plot of the raster image. The grey.colors take up the entire range of 256. Remember, that we created the variable breaks further up and that it contains the values at which the color will change in the image.
Key is creating the legend entry for the shapefile, while colorkey creates the legend for the raster images. The panel function allows the use of several plots in one, or in our case, it'll draw our cartographic grid of 4 lines.
Now let's get to the last and easy bit.


    Farben <- spplot(vector, zcol = "NAT", col.regions = vector_colors, cuts = c(0, 2, 4, 6, 8, 10))
    abb + as.layer(Farben)


As you can see all that's left to do is define the plotting parameters of the shapefile and then add the two plots together. Since we created variables for the plotting parameters we can simply put them together with a + and don't forget to add the shapefile as a layer ontop of the raster with the function as.layer. That's it. That's our function.

To see if the works load the Band 3 of the Fogo Landsat image and the shapefile containing the dataset with the number of natural species, check if they are loaded correctly and then run the function.

```{r}
landsat_Kanal3 <- raster("E:/MasterMarburg/Data Management/Data/fogo_landsat_2014-11-24/LC82100502014328LGN00_B3.tif")
plot(landsat_Kanal3)
Beob <- readOGR("E:/MasterMarburg/Data Management/Data/field_survey/data_2014_subset1.shp", "data_2014_subset1")
Beob <- spTransform(Beob, CRS(projection(landsat_Kanal3)))
Beob.Punkte <- Beob
plot(Beob.Punkte)
plot(Beob)
visualizer(landsat_Kanal3, Beob.Punkte, "Greens",5)
```

Well done! :) You stretched the colors and added a spatial point vector attribute